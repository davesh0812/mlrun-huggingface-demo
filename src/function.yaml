kind: job
metadata:
  name: hugging-face-classifier-trainer
  tag: ''
  hash: 7d7356b6aef44a228b69f03a4da8ffa6fc31fdcd
  project: ''
  labels:
    author: davids
  categories:
  - machine-learning
  - model-training
spec:
  command: ''
  args: []
  image: mlrun/ml-models
  build:
    functionSourceCode: aW1wb3J0IG9zCmltcG9ydCBzaHV0aWwKaW1wb3J0IHRlbXBmaWxlCmZyb20gYWJjIGltcG9ydCBBQkMKZnJvbSB0eXBpbmcgaW1wb3J0IERpY3QsIExpc3QsIE9wdGlvbmFsLCBBbnkKCmltcG9ydCBtbHJ1bgppbXBvcnQgbnVtcHkgYXMgbnAKCmltcG9ydCB0cmFuc2Zvcm1lcnMKZnJvbSBkYXRhc2V0cyBpbXBvcnQgRGF0YXNldCwgbG9hZF9kYXRhc2V0LCBsb2FkX21ldHJpYwpmcm9tIG1scnVuIGltcG9ydCBNTENsaWVudEN0eApmcm9tIG1scnVuLmFydGlmYWN0cyBpbXBvcnQgQXJ0aWZhY3QsIFBsb3RseUFydGlmYWN0CmZyb20gbWxydW4uZnJhbWV3b3Jrcy5fY29tbW9uIGltcG9ydCBDb21tb25UeXBlcywgTUxSdW5JbnRlcmZhY2UKZnJvbSBtbHJ1bi51dGlscyBpbXBvcnQgY3JlYXRlX2NsYXNzCmZyb20gcGxvdGx5IGltcG9ydCBncmFwaF9vYmplY3RzIGFzIGdvCgpmcm9tIHRyYW5zZm9ybWVycyBpbXBvcnQgKAogICAgQXV0b1Rva2VuaXplciwKICAgIERhdGFDb2xsYXRvcldpdGhQYWRkaW5nLAogICAgUHJlVHJhaW5lZE1vZGVsLAogICAgUHJlVHJhaW5lZFRva2VuaXplciwKICAgIFRyYWluZXIsCiAgICBUcmFpbmVyQ2FsbGJhY2ssCiAgICBUcmFpbmVyQ29udHJvbCwKICAgIFRyYWluZXJTdGF0ZSwKICAgIFRyYWluaW5nQXJndW1lbnRzLAopCgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tZnJvbSBNTFJVTi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCmNsYXNzIEhGVHJhaW5lck1MUnVuSW50ZXJmYWNlKE1MUnVuSW50ZXJmYWNlLCBBQkMpOgogICAgIiIiCiAgICBJbnRlcmZhY2UgZm9yIGFkZGluZyBNTFJ1biBmZWF0dXJlcyBmb3IgdGVuc29yZmxvdyBrZXJhcyBBUEkuCiAgICAiIiIKCiAgICAjIE1MUnVucyBjb250ZXh0IGRlZmF1bHQgbmFtZToKICAgIERFRkFVTFRfQ09OVEVYVF9OQU1FID0gIm1scnVuLWh1Z2dpbmdmYWNlIgoKICAgICMgQXR0cmlidXRlcyB0byByZXBsYWNlIHNvIHRoZSBNTFJ1biBpbnRlcmZhY2Ugd2lsbCBiZSBmdWxseSBlbmFibGVkLgogICAgX1JFUExBQ0VEX01FVEhPRFMgPSBbCiAgICAgICAgInRyYWluIiwKICAgICAgICAjICJldmFsdWF0ZSIKICAgIF0KCiAgICBAY2xhc3NtZXRob2QKICAgIGRlZiBhZGRfaW50ZXJmYWNlKAogICAgICAgIGNscywKICAgICAgICBvYmo6IFRyYWluZXIsCiAgICAgICAgcmVzdG9yYXRpb246IENvbW1vblR5cGVzLk1MUnVuSW50ZXJmYWNlUmVzdG9yYXRpb25UeXBlID0gTm9uZSwKICAgICk6CiAgICAgICAgIiIiCiAgICAgICAgRW5yaWNoIHRoZSBvYmplY3Qgd2l0aCB0aGlzIGludGVyZmFjZSBwcm9wZXJ0aWVzLCBtZXRob2RzIGFuZCBmdW5jdGlvbnMsIHNvIGl0IHdpbGwgaGF2ZSB0aGlzIFRlbnNvckZsb3cuS2VyYXMKICAgICAgICBNTFJ1bnMgZmVhdHVyZXMuCiAgICAgICAgOnBhcmFtIG9iajogICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0IHRvIGVucmljaCBoaXMgaW50ZXJmYWNlLgogICAgICAgIDpwYXJhbSByZXN0b3JhdGlvbjogUmVzdG9yYXRpb24gaW5mb3JtYXRpb24gdHVwbGUgYXMgcmV0dXJuZWQgZnJvbSAncmVtb3ZlX2ludGVyZmFjZScgaW4gb3JkZXIgdG8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZCB0aGUgaW50ZXJmYWNlIGluIGEgY2VydGFpbiBzdGF0ZS4KICAgICAgICAiIiIKCiAgICAgICAgc3VwZXIoSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UsIGNscykuYWRkX2ludGVyZmFjZSgKICAgICAgICAgICAgb2JqPW9iaiwgcmVzdG9yYXRpb249cmVzdG9yYXRpb24KICAgICAgICApCgogICAgQGNsYXNzbWV0aG9kCiAgICBkZWYgbWxydW5fdHJhaW4oY2xzKToKCiAgICAgICAgIiIiCiAgICAgICAgTUxSdW5zIHRmLmtlcmFzLk1vZGVsLmZpdCB3cmFwcGVyLiBJdCB3aWxsIHNldHVwIHRoZSBvcHRpbWl6ZXIgd2hlbiB1c2luZyBob3Jvdm9kLiBUaGUgb3B0aW1pemVyIG11c3QgYmUKICAgICAgICBwYXNzZWQgaW4gYSBrZXl3b3JkIGFyZ3VtZW50IGFuZCB3aGVuIHVzaW5nIGhvcm92b2QsIGl0IG11c3QgYmUgcGFzc2VkIGFzIGFuIE9wdGltaXplciBpbnN0YW5jZSwgbm90IGEgc3RyaW5nLgoKICAgICAgICByYWlzZSBNTFJ1bkludmFsaWRBcmd1bWVudEVycm9yOiBJbiBjYXNlIHRoZSBvcHRpbWl6ZXIgcHJvdmlkZWQgZGlkIG5vdCBmb2xsb3cgdGhlIGluc3RydWN0aW9ucyBhYm92ZS4KICAgICAgICAiIiIKCiAgICAgICAgZGVmIHdyYXBwZXIoc2VsZjogVHJhaW5lciwgKmFyZ3MsICoqa3dhcmdzKToKICAgICAgICAgICAgIyBSZXN0b3JlIHRoZSBldmFsdWF0aW9uIG1ldGhvZCBhcyBgdHJhaW5gIHdpbGwgdXNlIGl0OgogICAgICAgICAgICAjIGNscy5fcmVzdG9yZV9hdHRyaWJ1dGUob2JqPXNlbGYsIGF0dHJpYnV0ZV9uYW1lPSJldmFsdWF0ZSIpCgogICAgICAgICAgICAjIENhbGwgdGhlIG9yaWdpbmFsIGZpdCBtZXRob2Q6CiAgICAgICAgICAgIHJlc3VsdCA9IHNlbGYub3JpZ2luYWxfdHJhaW4oKmFyZ3MsICoqa3dhcmdzKQoKICAgICAgICAgICAgIyBSZXBsYWNlIHRoZSBldmFsdWF0aW9uIG1ldGhvZCBhZ2FpbjoKICAgICAgICAgICAgIyBjbHMuX3JlcGxhY2VfZnVuY3Rpb24ob2JqPXNlbGYsIGZ1bmN0aW9uX25hbWU9ImV2YWx1YXRlIikKCiAgICAgICAgICAgIHJldHVybiByZXN1bHQKCiAgICAgICAgcmV0dXJuIHdyYXBwZXIKCgpjbGFzcyBNTFJ1bkNhbGxiYWNrKFRyYWluZXJDYWxsYmFjayk6CiAgICAiIiIKICAgIENhbGxiYWNrIGZvciBjb2xsZWN0aW5nIGxvZ3MgZHVyaW5nIHRyYWluaW5nIC8gZXZhbHVhdGlvbiBvZiB0aGUgYFRyYWluZXJgIEFQSS4KICAgICIiIgoKICAgIGRlZiBfX2luaXRfXygKICAgICAgICBzZWxmLAogICAgICAgIGNvbnRleHQ6IG1scnVuLk1MQ2xpZW50Q3R4ID0gTm9uZSwKICAgICAgICBtb2RlbF9uYW1lOiBzdHIgPSAibW9kZWwiLAogICAgICAgIHRhZzogc3RyID0gIiIsCiAgICAgICAgbGFiZWxzOiBEaWN0W3N0ciwgc3RyXSA9IE5vbmUsCiAgICAgICAgZXh0cmFfZGF0YTogZGljdCA9IE5vbmUsCiAgICApOgogICAgICAgIHN1cGVyKCkuX19pbml0X18oKQoKICAgICAgICAjIFN0b3JlIHRoZSBjb25maWd1cmF0aW9uczoKICAgICAgICBzZWxmLl9jb250ZXh0ID0gKAogICAgICAgICAgICBjb250ZXh0CiAgICAgICAgICAgIGlmIGNvbnRleHQgaXMgbm90IE5vbmUKICAgICAgICAgICAgZWxzZSBtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eCgiLi9tbHJ1bi1odWdnaW5nZmFjZSIpCiAgICAgICAgKQogICAgICAgIHNlbGYuX21vZGVsX25hbWUgPSBtb2RlbF9uYW1lCiAgICAgICAgc2VsZi5fdGFnID0gdGFnCiAgICAgICAgc2VsZi5fbGFiZWxzID0gbGFiZWxzCiAgICAgICAgc2VsZi5fZXh0cmFfZGF0YSA9IGV4dHJhX2RhdGEgaWYgZXh0cmFfZGF0YSBpcyBub3QgTm9uZSBlbHNlIHt9CgogICAgICAgICMgU2V0IHVwIHRoZSBsb2dnaW5nIG1vZGU6CiAgICAgICAgc2VsZi5faXNfdHJhaW5pbmcgPSBGYWxzZQogICAgICAgIHNlbGYuX3N0ZXBzOiBMaXN0W0xpc3RbaW50XV0gPSBbXQogICAgICAgIHNlbGYuX21ldHJpY19zY29yZXM6IERpY3Rbc3RyLCBMaXN0W2Zsb2F0XV0gPSB7fQogICAgICAgIHNlbGYuX2FydGlmYWN0czogRGljdFtzdHIsIEFydGlmYWN0XSA9IHt9CgogICAgZGVmIG9uX2Vwb2NoX2JlZ2luKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICAqKmt3YXJncywKICAgICk6CiAgICAgICAgc2VsZi5fc3RlcHMuYXBwZW5kKFtdKQoKICAgIGRlZiBvbl9lcG9jaF9lbmQoCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9sb2dfbWV0cmljcygpCgogICAgZGVmIG9uX2xvZygKICAgICAgICBzZWxmLAogICAgICAgIGFyZ3M6IFRyYWluaW5nQXJndW1lbnRzLAogICAgICAgIHN0YXRlOiBUcmFpbmVyU3RhdGUsCiAgICAgICAgY29udHJvbDogVHJhaW5lckNvbnRyb2wsCiAgICAgICAgbG9nczogRGljdFtzdHIsIGZsb2F0XSA9IE5vbmUsCiAgICAgICAgKiprd2FyZ3MsCiAgICApOgogICAgICAgIHJlY2VudF9sb2dzID0gc3RhdGUubG9nX2hpc3RvcnlbLTFdLmNvcHkoKQoKICAgICAgICByZWNlbnRfbG9ncy5wb3AoImVwb2NoIikKICAgICAgICBjdXJyZW50X3N0ZXAgPSBpbnQocmVjZW50X2xvZ3MucG9wKCJzdGVwIikpCiAgICAgICAgaWYgY3VycmVudF9zdGVwIG5vdCBpbiBzZWxmLl9zdGVwc1stMV06CiAgICAgICAgICAgIHNlbGYuX3N0ZXBzWy0xXS5hcHBlbmQoY3VycmVudF9zdGVwKQoKICAgICAgICBmb3IgbWV0cmljX25hbWUsIG1ldHJpY19zY29yZSBpbiByZWNlbnRfbG9ncy5pdGVtcygpOgogICAgICAgICAgICBpZiBtZXRyaWNfbmFtZS5zdGFydHN3aXRoKCJ0cmFpbl8iKToKICAgICAgICAgICAgICAgIGlmIG1ldHJpY19uYW1lLnNwbGl0KCJ0cmFpbl8iKVsxXSBub3QgaW4gc2VsZi5fbWV0cmljX3Njb3JlczoKICAgICAgICAgICAgICAgICAgICBzZWxmLl9tZXRyaWNfc2NvcmVzW21ldHJpY19uYW1lXSA9IFttZXRyaWNfc2NvcmVdCiAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICBpZiBtZXRyaWNfbmFtZSBub3QgaW4gc2VsZi5fbWV0cmljX3Njb3JlczoKICAgICAgICAgICAgICAgIHNlbGYuX21ldHJpY19zY29yZXNbbWV0cmljX25hbWVdID0gW10KICAgICAgICAgICAgc2VsZi5fbWV0cmljX3Njb3Jlc1ttZXRyaWNfbmFtZV0uYXBwZW5kKG1ldHJpY19zY29yZSkKCiAgICBkZWYgb25fdHJhaW5fYmVnaW4oCiAgICAgICAgc2VsZiwKICAgICAgICBhcmdzOiBUcmFpbmluZ0FyZ3VtZW50cywKICAgICAgICBzdGF0ZTogVHJhaW5lclN0YXRlLAogICAgICAgIGNvbnRyb2w6IFRyYWluZXJDb250cm9sLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9pc190cmFpbmluZyA9IFRydWUKCiAgICBkZWYgb25fdHJhaW5fZW5kKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICBtb2RlbDogUHJlVHJhaW5lZE1vZGVsID0gTm9uZSwKICAgICAgICB0b2tlbml6ZXI6IFByZVRyYWluZWRUb2tlbml6ZXIgPSBOb25lLAogICAgICAgICoqa3dhcmdzLAogICAgKToKICAgICAgICBzZWxmLl9sb2dfbWV0cmljcygpCgogICAgICAgIHRlbXBfZGlyZWN0b3J5ID0gdGVtcGZpbGUuZ2V0dGVtcGRpcigpCgogICAgICAgICMgU2F2ZSBhbmQgbG9nIHRoZSB0b2tlbml6ZXI6CiAgICAgICAgaWYgdG9rZW5pemVyIGlzIG5vdCBOb25lOgogICAgICAgICAgICAjIFNhdmUgdG9rZW5pemVyOgogICAgICAgICAgICB0b2tlbml6ZXJfZGlyID0gb3MucGF0aC5qb2luKHRlbXBfZGlyZWN0b3J5LCAidG9rZW5pemVyIikKICAgICAgICAgICAgdG9rZW5pemVyLnNhdmVfcHJldHJhaW5lZChzYXZlX2RpcmVjdG9yeT10b2tlbml6ZXJfZGlyKQogICAgICAgICAgICAjIFppcCB0aGUgdG9rZW5pemVyIGRpcmVjdG9yeToKICAgICAgICAgICAgdG9rZW5pemVyX3ppcCA9IHNodXRpbC5tYWtlX2FyY2hpdmUoCiAgICAgICAgICAgICAgICBiYXNlX25hbWU9InRva2VuaXplciIsCiAgICAgICAgICAgICAgICBmb3JtYXQ9InppcCIsCiAgICAgICAgICAgICAgICByb290X2Rpcj10b2tlbml6ZXJfZGlyLAogICAgICAgICAgICApCiAgICAgICAgICAgICMgTG9nIHRoZSB6aXAgZmlsZToKICAgICAgICAgICAgc2VsZi5fYXJ0aWZhY3RzWyJ0b2tlbml6ZXIiXSA9IHNlbGYuX2NvbnRleHQubG9nX2FydGlmYWN0KAogICAgICAgICAgICAgICAgaXRlbT0idG9rZW5pemVyIiwgbG9jYWxfcGF0aD10b2tlbml6ZXJfemlwCiAgICAgICAgICAgICkKCiAgICAgICAgIyBTYXZlIHRoZSBtb2RlbDoKICAgICAgICBtb2RlbF9kaXIgPSBvcy5wYXRoLmpvaW4odGVtcF9kaXJlY3RvcnksICJtb2RlbCIpCiAgICAgICAgbW9kZWwuc2F2ZV9wcmV0cmFpbmVkKHNhdmVfZGlyZWN0b3J5PW1vZGVsX2RpcikKCiAgICAgICAgIyBaaXAgdGhlIG1vZGVsIGRpcmVjdG9yeToKICAgICAgICBzaHV0aWwubWFrZV9hcmNoaXZlKAogICAgICAgICAgICBiYXNlX25hbWU9Im1vZGVsIiwKICAgICAgICAgICAgZm9ybWF0PSJ6aXAiLAogICAgICAgICAgICByb290X2Rpcj1tb2RlbF9kaXIsCiAgICAgICAgKQoKICAgICAgICAjIExvZyB0aGUgbW9kZWw6CiAgICAgICAgc2VsZi5fY29udGV4dC5sb2dfbW9kZWwoCiAgICAgICAgICAgIGtleT0ibW9kZWwiLAogICAgICAgICAgICBkYl9rZXk9c2VsZi5fbW9kZWxfbmFtZSwKICAgICAgICAgICAgbW9kZWxfZmlsZT0ibW9kZWwuemlwIiwKICAgICAgICAgICAgdGFnPXNlbGYuX3RhZywKICAgICAgICAgICAgZnJhbWV3b3JrPSJIdWdnaW5nIEZhY2UiLAogICAgICAgICAgICBsYWJlbHM9c2VsZi5fbGFiZWxzLAogICAgICAgICAgICBleHRyYV9kYXRhPXsqKnNlbGYuX2FydGlmYWN0cywgKipzZWxmLl9leHRyYV9kYXRhfSwKICAgICAgICApCgogICAgZGVmIG9uX2V2YWx1YXRlKAogICAgICAgIHNlbGYsCiAgICAgICAgYXJnczogVHJhaW5pbmdBcmd1bWVudHMsCiAgICAgICAgc3RhdGU6IFRyYWluZXJTdGF0ZSwKICAgICAgICBjb250cm9sOiBUcmFpbmVyQ29udHJvbCwKICAgICAgICAqKmt3YXJncywKICAgICk6CiAgICAgICAgc2VsZi5fbG9nX21ldHJpY3MoKQoKICAgICAgICBpZiBzZWxmLl9pc190cmFpbmluZzoKICAgICAgICAgICAgcmV0dXJuCgogICAgICAgICMgVE9ETzogVXBkYXRlIHRoZSBtb2RlbCBvYmplY3QKCiAgICBkZWYgX2xvZ19tZXRyaWNzKHNlbGYpOgogICAgICAgIGZvciBtZXRyaWNfbmFtZSwgbWV0cmljX3Njb3JlcyBpbiBzZWxmLl9tZXRyaWNfc2NvcmVzLml0ZW1zKCk6CiAgICAgICAgICAgIHNlbGYuX2NvbnRleHQubG9nX3Jlc3VsdChrZXk9bWV0cmljX25hbWUsIHZhbHVlPW1ldHJpY19zY29yZXNbLTFdKQogICAgICAgICAgICBpZiBsZW4obWV0cmljX3Njb3JlcykgPiAxOgogICAgICAgICAgICAgICAgc2VsZi5fbG9nX21ldHJpY19wbG90KG5hbWU9bWV0cmljX25hbWUsIHNjb3Jlcz1tZXRyaWNfc2NvcmVzKQogICAgICAgIHNlbGYuX2NvbnRleHQuY29tbWl0KGNvbXBsZXRlZD1GYWxzZSkKCiAgICBkZWYgX2xvZ19tZXRyaWNfcGxvdChzZWxmLCBuYW1lOiBzdHIsIHNjb3JlczogTGlzdFtmbG9hdF0pOgogICAgICAgICMgSW5pdGlhbGl6ZSBhIHBsb3RseSBmaWd1cmU6CiAgICAgICAgbWV0cmljX2ZpZ3VyZSA9IGdvLkZpZ3VyZSgpCgogICAgICAgICMgQWRkIHRpdGxlczoKICAgICAgICBtZXRyaWNfZmlndXJlLnVwZGF0ZV9sYXlvdXQoCiAgICAgICAgICAgIHRpdGxlPW5hbWUuY2FwaXRhbGl6ZSgpLnJlcGxhY2UoIl8iLCAiICIpLAogICAgICAgICAgICB4YXhpc190aXRsZT0iU2FtcGxlcyIsCiAgICAgICAgICAgIHlheGlzX3RpdGxlPSJTY29yZXMiLAogICAgICAgICkKCiAgICAgICAgIyBEcmF3OgogICAgICAgIG1ldHJpY19maWd1cmUuYWRkX3RyYWNlKAogICAgICAgICAgICBnby5TY2F0dGVyKHg9bnAuYXJhbmdlKGxlbihzY29yZXMpKSwgeT1zY29yZXMsIG1vZGU9ImxpbmVzIikKICAgICAgICApCgogICAgICAgICMgQ3JlYXRlIHRoZSBwbG90bHkgYXJ0aWZhY3Q6CiAgICAgICAgYXJ0aWZhY3RfbmFtZSA9IGYie25hbWV9X3Bsb3QiCiAgICAgICAgYXJ0aWZhY3QgPSBQbG90bHlBcnRpZmFjdChrZXk9YXJ0aWZhY3RfbmFtZSwgZmlndXJlPW1ldHJpY19maWd1cmUpCiAgICAgICAgc2VsZi5fYXJ0aWZhY3RzW2FydGlmYWN0X25hbWVdID0gc2VsZi5fY29udGV4dC5sb2dfYXJ0aWZhY3QoYXJ0aWZhY3QpCgoKZGVmIGFwcGx5X21scnVuKAogICAgaHVnZ2luZ2ZhY2Vfb2JqZWN0OiB0cmFuc2Zvcm1lcnMuVHJhaW5lciwKICAgIG1vZGVsX25hbWU6IHN0ciA9IE5vbmUsCiAgICB0YWc6IHN0ciA9ICIiLAogICAgY29udGV4dDogbWxydW4uTUxDbGllbnRDdHggPSBOb25lLAogICAgYXV0b19sb2c6IGJvb2wgPSBUcnVlLAogICAgbGFiZWxzOiBEaWN0W3N0ciwgc3RyXSA9IE5vbmUsCiAgICBleHRyYV9kYXRhOiBkaWN0ID0gTm9uZSwKICAgICoqa3dhcmdzLAopOgogICAgIiIiCiAgICBXcmFwIHRoZSBnaXZlbiBtb2RlbCB3aXRoIE1MUnVuJ3MgaW50ZXJmYWNlIHByb3ZpZGluZyBpdCB3aXRoIG1scnVuJ3MgYWRkaXRpb25hbCBmZWF0dXJlcy4KICAgIDpwYXJhbSBodWdnaW5nZmFjZV9vYmplY3Q6IFRoZSBtb2RlbCB0byB3cmFwLiBDYW4gYmUgbG9hZGVkIGZyb20gdGhlIG1vZGVsIHBhdGggZ2l2ZW4gYXMgd2VsbC4KICAgIDpwYXJhbSBtb2RlbF9uYW1lOiAgICAgICAgIFRoZSBtb2RlbCBuYW1lIHRvIHVzZSBmb3Igc3RvcmluZyB0aGUgbW9kZWwgYXJ0aWZhY3QuIERlZmF1bHQ6ICJtb2RlbCIuCiAgICA6cGFyYW0gdGFnOiAgICAgICAgICAgICAgICBUaGUgbW9kZWwncyB0YWcgdG8gbG9nIHdpdGguCiAgICA6cGFyYW0gY29udGV4dDogICAgICAgICAgICBNTFJ1biBjb250ZXh0IHRvIHdvcmsgd2l0aC4gSWYgbm8gY29udGV4dCBpcyBnaXZlbiBpdCB3aWxsIGJlIHJldHJpZXZlZCB2aWEKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtbHJ1bi5nZXRfb3JfY3JlYXRlX2N0eChOb25lKScKICAgIDpwYXJhbSBhdXRvX2xvZzogICAgICAgICAgIFdoZXRoZXIgdG8gZW5hYmxlIE1MUnVuJ3MgYXV0byBsb2dnaW5nLiBEZWZhdWx0OiBUcnVlLgogICAgIiIiCiAgICBpZiBpc2luc3RhbmNlKGh1Z2dpbmdmYWNlX29iamVjdCwgdHJhbnNmb3JtZXJzLlRyYWluZXIpOgogICAgICAgIGlmIGNvbnRleHQgaXMgTm9uZToKICAgICAgICAgICAgY29udGV4dCA9IG1scnVuLmdldF9vcl9jcmVhdGVfY3R4KAogICAgICAgICAgICAgICAgSEZUcmFpbmVyTUxSdW5JbnRlcmZhY2UuREVGQVVMVF9DT05URVhUX05BTUUKICAgICAgICAgICAgKQoKICAgICAgICBIRlRyYWluZXJNTFJ1bkludGVyZmFjZS5hZGRfaW50ZXJmYWNlKG9iaj1odWdnaW5nZmFjZV9vYmplY3QpCgogICAgICAgIGlmIGF1dG9fbG9nOgogICAgICAgICAgICBodWdnaW5nZmFjZV9vYmplY3QuYWRkX2NhbGxiYWNrKAogICAgICAgICAgICAgICAgTUxSdW5DYWxsYmFjaygKICAgICAgICAgICAgICAgICAgICBjb250ZXh0PWNvbnRleHQsCiAgICAgICAgICAgICAgICAgICAgbW9kZWxfbmFtZT1tb2RlbF9uYW1lLAogICAgICAgICAgICAgICAgICAgIHRhZz10YWcsCiAgICAgICAgICAgICAgICAgICAgbGFiZWxzPWxhYmVscywKICAgICAgICAgICAgICAgICAgICBleHRyYV9kYXRhPWV4dHJhX2RhdGEsCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICkKICAgICAgICByZXR1cm4KICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1bkludmFsaWRBcmd1bWVudEVycm9yCgoKIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGZyb20gYXV0b190cmFpbmVyLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KY2xhc3MgS1dBcmdzUHJlZml4ZXM6CiAgICBNT0RFTF9DTEFTUyA9ICJDTEFTU18iCiAgICBGSVQgPSAiRklUXyIKICAgIFRSQUlOID0gIlRSQUlOXyIKICAgIFBSRURJQ1QgPSAiUFJFRElDVF8iCgoKZGVmIF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KHNyYzogRGljdCwgcHJlZml4X2tleTogc3RyKSAtPiBEaWN0W3N0ciwgQW55XToKICAgICIiIgogICAgQ29sbGVjdCBhbGwgdGhlIGtleXMgZnJvbSB0aGUgZ2l2ZW4gZGljdCB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBwcmVmaXggYW5kIGNyZWF0ZXMgYSBuZXcgZGljdGlvbmFyeSB3aXRoIHRoZXNlCiAgICBrZXlzLgoKICAgIDpwYXJhbSBzcmM6ICAgICAgICAgVGhlIHNvdXJjZSBkaWN0IHRvIGV4dHJhY3QgdGhlIHZhbHVlcyBmcm9tLgogICAgOnBhcmFtIHByZWZpeF9rZXk6ICBPbmx5IGtleXMgd2l0aCB0aGlzIHByZWZpeCB3aWxsIGJlIHJldHVybmVkLiBUaGUga2V5cyBpbiB0aGUgcmVzdWx0IGRpY3Qgd2lsbCBiZSB3aXRob3V0IHRoaXMKICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4LgogICAgIiIiCiAgICByZXR1cm4gewogICAgICAgIGtleS5yZXBsYWNlKHByZWZpeF9rZXksICIiKTogdmFsCiAgICAgICAgZm9yIGtleSwgdmFsIGluIHNyYy5pdGVtcygpCiAgICAgICAgaWYga2V5LnN0YXJ0c3dpdGgocHJlZml4X2tleSkKICAgIH0KCgojIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSHVnZ2luZyBGYWNlIFRyYWluZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCgpkZWYgX2NyZWF0ZV9jb21wdXRlX21ldHJpY3MobWV0cmljczogTGlzdFtzdHJdKToKICAgIGRlZiBfY29tcHV0ZV9tZXRyaWNzKGV2YWxfcHJlZCk6CiAgICAgICAgbG9naXRzLCBsYWJlbHMgPSBldmFsX3ByZWQKICAgICAgICBwcmVkaWN0aW9ucyA9IG5wLmFyZ21heChsb2dpdHMsIGF4aXM9LTEpCiAgICAgICAgbWV0cmljX2RpY3RfcmVzdWx0cyA9IHt9CiAgICAgICAgZm9yIG1ldHJpYyBpbiBtZXRyaWNzOgogICAgICAgICAgICBsb2FkX21ldCA9IGxvYWRfbWV0cmljKG1ldHJpYykKICAgICAgICAgICAgbWV0cmljX3JlcyA9IGxvYWRfbWV0LmNvbXB1dGUocHJlZGljdGlvbnM9cHJlZGljdGlvbnMsIHJlZmVyZW5jZXM9bGFiZWxzKVsKICAgICAgICAgICAgICAgIG1ldHJpYwogICAgICAgICAgICBdCiAgICAgICAgICAgIG1ldHJpY19kaWN0X3Jlc3VsdHNbbWV0cmljXSA9IG1ldHJpY19yZXMKCiAgICAgICAgcmV0dXJuIG1ldHJpY19kaWN0X3Jlc3VsdHMKCiAgICByZXR1cm4gX2NvbXB1dGVfbWV0cmljcwoKCmRlZiBfZWRpdF9jb2x1bW5zKAogICAgZGF0YXNldDogRGF0YXNldCwKICAgIGRyb3BfY29sdW1uczogTGlzdFtzdHJdID0gTm9uZSwKICAgIHJlbmFtZV9jb2x1bW5zOiBbc3RyLCBzdHJdID0gTm9uZSwKKToKICAgIGlmIGRyb3BfY29sdW1uczoKICAgICAgICBkYXRhc2V0ID0gZGF0YXNldC5yZW1vdmVfY29sdW1ucyhkcm9wX2NvbHVtbnMpCiAgICBpZiByZW5hbWVfY29sdW1uczoKICAgICAgICBkYXRhc2V0ID0gZGF0YXNldC5yZW5hbWVfY29sdW1ucyhyZW5hbWVfY29sdW1ucykKICAgIHJldHVybiBkYXRhc2V0CgoKZGVmIF9wcmVwYXJlX2RhdGFzZXQoCiAgICBjb250ZXh0OiBNTENsaWVudEN0eCwKICAgIGRhdGFzZXRfbmFtZTogc3RyLAogICAgbGFiZWxfbmFtZTogc3RyID0gTm9uZSwKICAgIGRyb3BfY29sdW1uczogT3B0aW9uYWxbTGlzdFtzdHJdXSA9IE5vbmUsCiAgICBudW1fb2ZfdHJhaW5fc2FtcGxlczogaW50ID0gTm9uZSwKICAgIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZTogZmxvYXQgPSBOb25lLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSBOb25lLAopOgogICAgIiIiCiAgICBMb2FkaW5nIHRoZSBkYXRhc2V0IGFuZCBlZGl0aW5nIHRoZSBjb2x1bW5zCgogICAgOnBhcmFtIGNvbnRleHQ6ICAgICAgICAgICAgICAgICBNTFJ1biBjb250ZXgKICAgIDpwYXJhbSBkYXRhc2V0X25hbWU6ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gZ2V0IGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1YgogICAgOnBhcmFtIGxhYmVsX25hbWU6CiAgICA6cGFyYW0gZHJvcF9jb2x1bW5zOiAgICAgICAgICAgIFRoZSBjb2x1bW5zIHRvIGRyb3AgZnJvbSB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSBudW1fb2ZfdHJhaW5fc2FtcGxlczogICAgTWF4IG51bWJlciBvZiB0cmFpbmluZyBzYW1wbGVzLCBmb3IgZGVidWdnaW5nLgogICAgOnBhcmFtIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZTogICBTaG91bGQgYmUgYmV0d2VlbiAwLjAgYW5kIDEuMCBhbmQgcmVwcmVzZW50IHRoZSBwcm9wb3J0aW9uIG9mIHRoZSBkYXRhc2V0IHRvIGluY2x1ZGUKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gdGhlIHRlc3Qgc3BsaXQuCiAgICA6cGFyYW0gcmFuZG9tX3N0YXRlOiAgICAgICAgICAgIFJhbmRvbSBzdGF0ZSBmb3IgdHJhaW5fdGVzdF9zcGxpdAoKICAgICIiIgoKICAgIGNvbnRleHQubG9nZ2VyLmluZm8oCiAgICAgICAgZiJMb2FkaW5nIGFuZCBlZGl0aW5nIHtkYXRhc2V0X25hbWV9IGRhdGFzZXQgZnJvbSBIdWdnaW5nIEZhY2UgaHViIgogICAgKQogICAgcmVuYW1lX2NvbHMgPSB7bGFiZWxfbmFtZTogImxhYmVscyJ9CgogICAgIyBMb2FkaW5nIGFuZCBlZGl0aW5nIGRhdGFzZXQ6CiAgICBkYXRhc2V0ID0gbG9hZF9kYXRhc2V0KGRhdGFzZXRfbmFtZSkKCiAgICAjIHRyYWluIHNldAogICAgdHJhaW5fZGF0YXNldCA9IGRhdGFzZXRbInRyYWluIl0KICAgIGlmIG51bV9vZl90cmFpbl9zYW1wbGVzOgogICAgICAgIHRyYWluX2RhdGFzZXQgPSB0cmFpbl9kYXRhc2V0LnNodWZmbGUoc2VlZD1yYW5kb21fc3RhdGUpLnNlbGVjdCgKICAgICAgICAgICAgbGlzdChyYW5nZShudW1fb2ZfdHJhaW5fc2FtcGxlcykpCiAgICAgICAgKQogICAgdHJhaW5fZGF0YXNldCA9IF9lZGl0X2NvbHVtbnModHJhaW5fZGF0YXNldCwgZHJvcF9jb2x1bW5zLCByZW5hbWVfY29scykKCiAgICAjIHRlc3Qgc2V0CiAgICB0ZXN0X2RhdGFzZXQgPSBkYXRhc2V0WyJ0ZXN0Il0KICAgIGlmIHRyYWluX3Rlc3Rfc3BsaXRfc2l6ZSBvciBudW1fb2ZfdHJhaW5fc2FtcGxlczoKICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUgPSB0cmFpbl90ZXN0X3NwbGl0X3NpemUgb3IgMC4yCiAgICAgICAgbnVtX29mX3Rlc3Rfc2FtcGxlcyA9IGludCgKICAgICAgICAgICAgKHRyYWluX2RhdGFzZXQubnVtX3Jvd3MgKiB0cmFpbl90ZXN0X3NwbGl0X3NpemUpIC8vICgxIC0gdHJhaW5fdGVzdF9zcGxpdF9zaXplKQogICAgICAgICkKICAgICAgICB0ZXN0X2RhdGFzZXQgPSAoCiAgICAgICAgICAgIHRlc3RfZGF0YXNldAogICAgICAgICAgICAuc2h1ZmZsZShzZWVkPXJhbmRvbV9zdGF0ZSkKICAgICAgICAgICAgLnNlbGVjdChsaXN0KHJhbmdlKG51bV9vZl90ZXN0X3NhbXBsZXMpKSkKICAgICAgICApCiAgICB0ZXN0X2RhdGFzZXQgPSBfZWRpdF9jb2x1bW5zKHRlc3RfZGF0YXNldCwgZHJvcF9jb2x1bW5zLCByZW5hbWVfY29scykKCiAgICByZXR1cm4gdHJhaW5fZGF0YXNldCwgdGVzdF9kYXRhc2V0CgoKCmRlZiB0cmFpbigKICAgIGNvbnRleHQ6IE1MQ2xpZW50Q3R4LAogICAgZGF0YXNldF9uYW1lOiBzdHIgPSBOb25lLAogICAgZHJvcF9jb2x1bW5zOiBPcHRpb25hbFtMaXN0W3N0cl1dID0gTm9uZSwKICAgIHByZXRyYWluZWRfdG9rZW5pemVyOiBzdHIgPSBOb25lLAogICAgcHJldHJhaW5lZF9tb2RlbDogc3RyID0gTm9uZSwKICAgIG1vZGVsX2NsYXNzOiBzdHIgPSBOb25lLAogICAgbW9kZWxfbmFtZTogc3RyID0gImh1Z2dpbmdmYWNlX21vZGVsIiwKICAgIGxhYmVsX25hbWU6IHN0ciA9ICJsYWJlbHMiLAogICAgdGV4dF9jb2w6IHN0ciA9ICJ0ZXh0IiwKICAgIG51bV9vZl90cmFpbl9zYW1wbGVzOiBpbnQgPSBOb25lLAogICAgdHJhaW5fdGVzdF9zcGxpdF9zaXplOiBmbG9hdCA9IE5vbmUsCiAgICBtZXRyaWNzOiBMaXN0W3N0cl0gPSBOb25lLAogICAgcmFuZG9tX3N0YXRlOiBpbnQgPSBOb25lLAopOgogICAgIiIiCiAgICBUcmFpbmluZyBhbmQgZXZhbHVhdGluZyBhIHByZXRyYWluZWQgbW9kZWwgd2l0aCBhIHByZXRyYWluZWQgdG9rZW5pemVyIG92ZXIgYSBkYXRhc2V0LgoKICAgIDpwYXJhbSBjb250ZXh0OiAgICAgICAgICAgICAgICAgTUxSdW4gY29udGV4dAogICAgOnBhcmFtIGRhdGFzZXRfbmFtZTogICAgICAgICAgICBUaGUgbmFtZSBvZiB0aGUgZGF0YXNldCB0byBnZXQgZnJvbSB0aGUgSHVnZ2luZ0ZhY2UgaHViCiAgICA6cGFyYW0gZHJvcF9jb2x1bW5zOiAgICAgICAgICAgIFRoZSBjb2x1bW5zIHRvIGRyb3AgZnJvbSB0aGUgZGF0YXNldC4KICAgIDpwYXJhbSBwcmV0cmFpbmVkX3Rva2VuaXplcjogICAgVGhlIG5hbWUgb2YgdGhlIHByZXRyYWluZWQgdG9rZW5pemVyIGZyb20gdGhlIEh1Z2dpbmdGYWNlIGh1Yi4KICAgIDpwYXJhbSBwcmV0cmFpbmVkX21vZGVsOiAgICAgICAgVGhlIG5hbWUgb2YgdGhlIHByZXRyYWluZWQgbW9kZWwgZnJvbSB0aGUgSHVnZ2luZ0ZhY2UgaHViLgogICAgOnBhcmFtIG1vZGVsX25hbWU6ICAgICAgICAgICAgICBUaGUgbW9kZWwncyBuYW1lIHRvIHVzZSBmb3Igc3RvcmluZyB0aGUgbW9kZWwgYXJ0aWZhY3QsIGRlZmF1bHQgdG8gJ21vZGVsJwogICAgOnBhcmFtIG1vZGVsX2NsYXNzOiAgICAgICAgICAgICBUaGUgY2xhc3Mgb2YgdGhlIG1vZGVsLCBlLmcuIGB0cmFuc2Zvcm1lcnMuQXV0b01vZGVsRm9yU2VxdWVuY2VDbGFzc2lmaWNhdGlvbmAKICAgIDpwYXJhbSBsYWJlbF9uYW1lOiAgICAgICAgICAgICAgVGhlIHRhcmdldCBsYWJlbCBvZiB0aGUgY29sdW1uIGluIHRoZSBkYXRhc2V0LgogICAgOnBhcmFtIHRleHRfY29sOiAgICAgICAgICAgICAgICBUaGUgaW5wdXQgdGV4dCBjb2x1bW4gdW4gdGhlIGRhdGFzZXQuCiAgICA6cGFyYW0gbnVtX29mX3RyYWluX3NhbXBsZXM6ICAgIE1heCBudW1iZXIgb2YgdHJhaW5pbmcgc2FtcGxlcywgZm9yIGRlYnVnZ2luZy4KICAgIDpwYXJhbSB0cmFpbl90ZXN0X3NwbGl0X3NpemU6ICAgU2hvdWxkIGJlIGJldHdlZW4gMC4wIGFuZCAxLjAgYW5kIHJlcHJlc2VudCB0aGUgcHJvcG9ydGlvbiBvZiB0aGUgZGF0YXNldCB0byBpbmNsdWRlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRoZSB0ZXN0IHNwbGl0LgogICAgOnBhcmFtIG1ldHJpY3M6ICAgICAgICAgICAgICAgICBMaXN0IG9mIGRpZmZlcmVudCBtZXRyaWNzIGZvciBldmFsdWF0ZSB0aGUgbW9kZWwgc3VjaCBhcyBmMSwgYWNjdXJhY3kgZXRjLgogICAgOnBhcmFtIHJhbmRvbV9zdGF0ZTogICAgICAgICAgICBSYW5kb20gc3RhdGUgZm9yIHRyYWluX3Rlc3Rfc3BsaXQKICAgICIiIgoKICAgIGlmIG5vdCBsYWJlbF9uYW1lIG9yIG5vdCBwcmV0cmFpbmVkX3Rva2VuaXplcjoKICAgICAgICByYWlzZSBtbHJ1bi5lcnJvcnMuTUxSdW5SdW50aW1lRXJyb3IoCiAgICAgICAgICAgICJNdXN0IHByb3ZpZGUgbGFiZWxfbmFtZXMgYW5kIHByZXRyYWluZWRfdG9rZW5pemVyIgogICAgICAgICkKCiAgICAjIENyZWF0aW5nIHRva2VuaXplcjoKICAgIHRva2VuaXplciA9IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHByZXRyYWluZWRfdG9rZW5pemVyKQoKICAgIGRlZiBwcmVwcm9jZXNzX2Z1bmN0aW9uKGV4YW1wbGVzKToKICAgICAgICByZXR1cm4gdG9rZW5pemVyKGV4YW1wbGVzW3RleHRfY29sXSwgdHJ1bmNhdGlvbj1UcnVlKQoKICAgICMgcHJlcGFyZSBkYXRhIGZvciB0cmFpbmluZwogICAgdHJhaW5fZGF0YXNldCwgdGVzdF9kYXRhc2V0ID0gX3ByZXBhcmVfZGF0YXNldCgKICAgICAgICBjb250ZXh0LAogICAgICAgIGRhdGFzZXRfbmFtZSwKICAgICAgICBsYWJlbF9uYW1lLAogICAgICAgIGRyb3BfY29sdW1ucywKICAgICAgICBudW1fb2ZfdHJhaW5fc2FtcGxlcywKICAgICAgICB0cmFpbl90ZXN0X3NwbGl0X3NpemUsCiAgICAgICAgcmFuZG9tX3N0YXRlPXJhbmRvbV9zdGF0ZSwKICAgICkKCiAgICAjIE1hcHBpbmcgZGF0YXNldHMgd2l0aCB0aGUgdG9rZW5pemVyOgogICAgdG9rZW5pemVkX3RyYWluID0gdHJhaW5fZGF0YXNldC5tYXAocHJlcHJvY2Vzc19mdW5jdGlvbiwgYmF0Y2hlZD1UcnVlKQogICAgdG9rZW5pemVkX3Rlc3QgPSB0ZXN0X2RhdGFzZXQubWFwKHByZXByb2Nlc3NfZnVuY3Rpb24sIGJhdGNoZWQ9VHJ1ZSkKCiAgICAjIENyZWF0aW5nIGRhdGEgY29sbGF0b3IgZm9yIGJhdGNoaW5nOgogICAgZGF0YV9jb2xsYXRvciA9IERhdGFDb2xsYXRvcldpdGhQYWRkaW5nKHRva2VuaXplcj10b2tlbml6ZXIpCgogICAgIyBQYXJzaW5nIGt3YXJnczoKICAgIHRyYWluX2t3YXJncyA9IF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KAogICAgICAgIHNyYz1jb250ZXh0LnBhcmFtZXRlcnMsIHByZWZpeF9rZXk9S1dBcmdzUHJlZml4ZXMuVFJBSU4KICAgICkKICAgIG1vZGVsX2NsYXNzX2t3YXJncyA9IF9nZXRfc3ViX2RpY3RfYnlfcHJlZml4KAogICAgICAgIHNyYz1jb250ZXh0LnBhcmFtZXRlcnMsIHByZWZpeF9rZXk9S1dBcmdzUHJlZml4ZXMuTU9ERUxfQ0xBU1MKICAgICkKCiAgICAjIExvYWRpbmcgb3VyIHByZXRyYWluZWQgbW9kZWw6CiAgICBtb2RlbF9jbGFzc19rd2FyZ3NbInByZXRyYWluZWRfbW9kZWxfbmFtZV9vcl9wYXRoIl0gPSAoCiAgICAgICAgbW9kZWxfY2xhc3Nfa3dhcmdzLmdldCgicHJldHJhaW5lZF9tb2RlbF9uYW1lX29yX3BhdGgiKSBvciBwcmV0cmFpbmVkX21vZGVsCiAgICApCiAgICBpZiBub3QgbW9kZWxfY2xhc3Nfa3dhcmdzWyJwcmV0cmFpbmVkX21vZGVsX25hbWVfb3JfcGF0aCJdOgogICAgICAgIHJhaXNlIG1scnVuLmVycm9ycy5NTFJ1blJ1bnRpbWVFcnJvcigKICAgICAgICAgICAgIk11c3QgcHJvdmlkZSBwcmV0cmFpbmVkX21vZGVsIG5hbWUgYXMgIgogICAgICAgICAgICAiZnVuY3Rpb24gYXJndW1lbnQgb3IgaW4gZXh0cmEgcGFyYW1zIgogICAgICAgICkKICAgIG1vZGVsID0gY3JlYXRlX2NsYXNzKG1vZGVsX2NsYXNzKS5mcm9tX3ByZXRyYWluZWQoKiptb2RlbF9jbGFzc19rd2FyZ3MpCgogICAgIyBQcmVwYXJpbmcgdHJhaW5pbmcgYXJndW1lbnRzOgogICAgdHJhaW5pbmdfYXJncyA9IFRyYWluaW5nQXJndW1lbnRzKAogICAgICAgICoqdHJhaW5fa3dhcmdzLAogICAgKQoKICAgIGNvbXB1dGVfbWV0cmljcyA9IF9jcmVhdGVfY29tcHV0ZV9tZXRyaWNzKG1ldHJpY3MpIGlmIG1ldHJpY3MgZWxzZSBOb25lCiAgICB0cmFpbmVyID0gVHJhaW5lcigKICAgICAgICBtb2RlbD1tb2RlbCwKICAgICAgICBhcmdzPXRyYWluaW5nX2FyZ3MsCiAgICAgICAgdHJhaW5fZGF0YXNldD10b2tlbml6ZWRfdHJhaW4sCiAgICAgICAgZXZhbF9kYXRhc2V0PXRva2VuaXplZF90ZXN0LAogICAgICAgIHRva2VuaXplcj10b2tlbml6ZXIsCiAgICAgICAgZGF0YV9jb2xsYXRvcj1kYXRhX2NvbGxhdG9yLAogICAgICAgIGNvbXB1dGVfbWV0cmljcz1jb21wdXRlX21ldHJpY3MsCiAgICApCgogICAgYXBwbHlfbWxydW4odHJhaW5lciwgbW9kZWxfbmFtZT1tb2RlbF9uYW1lKQoKICAgICMgQXBwbHkgdHJhaW5pbmcgd2l0aCBldmFsdWF0aW9uOgogICAgY29udGV4dC5sb2dnZXIuaW5mbyhmInRyYWluaW5nICd7bW9kZWxfbmFtZX0nIikKICAgIHRyYWluZXIudHJhaW4oKQo=
    commands:
    - python -m pip install transformers datasets
    code_origin: https://github.com/davesh0812/functions.git#bb5e4bba28ad92d644c942ea837f4bae7484e1d4:/Users/davids/Projects/functions/hugging_face_classifier_trainer/hugging_face_classifier_trainer.py
    origin_filename: /Users/davids/Projects/functions/hugging_face_classifier_trainer/hugging_face_classifier_trainer.py
  entry_points:
    add_interface:
      name: add_interface
      doc: 'Enrich the object with this interface properties, methods and functions,
        so it will have this TensorFlow.Keras

        MLRuns features.'
      parameters:
      - name: cls
        default: ''
      - name: obj
        type: Trainer
        doc: The object to enrich his interface.
        default: ''
      - name: restoration
        type: MLRunInterfaceRestorationType
        doc: Restoration information tuple as returned from 'remove_interface' in
          order to add the interface in a certain state.
        default: null
      outputs:
      - default: ''
      lineno: 46
    mlrun_train:
      name: mlrun_train
      doc: 'MLRuns tf.keras.Model.fit wrapper. It will setup the optimizer when using
        horovod. The optimizer must be

        passed in a keyword argument and when using horovod, it must be passed as
        an Optimizer instance, not a string.


        raise MLRunInvalidArgumentError: In case the optimizer provided did not follow
        the instructions above.'
      parameters:
      - name: cls
        default: ''
      outputs:
      - default: ''
      lineno: 64
    wrapper:
      name: wrapper
      doc: ''
      parameters:
      - name: self
        type: Trainer
        default: ''
      outputs:
      - default: ''
      lineno: 74
    on_epoch_begin:
      name: on_epoch_begin
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 121
    on_epoch_end:
      name: on_epoch_end
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 130
    on_log:
      name: on_log
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      - name: logs
        type: Dict[str, float]
        default: null
      outputs:
      - default: ''
      lineno: 139
    on_train_begin:
      name: on_train_begin
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 163
    on_train_end:
      name: on_train_end
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      - name: model
        type: PreTrainedModel
        default: null
      - name: tokenizer
        type: PreTrainedTokenizer
        default: null
      outputs:
      - default: ''
      lineno: 172
    on_evaluate:
      name: on_evaluate
      doc: ''
      parameters:
      - name: self
        default: ''
      - name: args
        type: TrainingArguments
        default: ''
      - name: state
        type: TrainerState
        default: ''
      - name: control
        type: TrainerControl
        default: ''
      outputs:
      - default: ''
      lineno: 223
    apply_mlrun:
      name: apply_mlrun
      doc: Wrap the given model with MLRun's interface providing it with mlrun's additional
        features.
      parameters:
      - name: huggingface_object
        type: Trainer
        doc: The model to wrap. Can be loaded from the model path given as well.
        default: ''
      - name: model_name
        type: str
        doc: 'The model name to use for storing the model artifact. Default: "model".'
        default: null
      - name: tag
        type: str
        doc: The model's tag to log with.
        default: ''
      - name: context
        type: MLClientCtx
        doc: MLRun context to work with. If no context is given it will be retrieved
          via 'mlrun.get_or_create_ctx(None)'
        default: null
      - name: auto_log
        type: bool
        doc: 'Whether to enable MLRun''s auto logging. Default: True.'
        default: true
      - name: labels
        type: Dict[str, str]
        default: null
      - name: extra_data
        type: dict
        default: null
      outputs:
      - default: ''
      lineno: 266
    train:
      name: train
      doc: Training and evaluating a pretrained model with a pretrained tokenizer
        over a dataset.
      parameters:
      - name: context
        type: MLClientCtx
        doc: MLRun context
        default: ''
      - name: dataset_name
        type: str
        doc: The name of the dataset to get from the HuggingFace hub
        default: null
      - name: drop_columns
        type: Optional[List[str]]
        doc: The columns to drop from the dataset.
        default: null
      - name: pretrained_tokenizer
        type: str
        doc: The name of the pretrained tokenizer from the HuggingFace hub.
        default: null
      - name: pretrained_model
        type: str
        doc: The name of the pretrained model from the HuggingFace hub.
        default: null
      - name: model_class
        type: str
        doc: The class of the model, e.g. `transformers.AutoModelForSequenceClassification`
        default: null
      - name: model_name
        type: str
        doc: The model's name to use for storing the model artifact, default to 'model'
        default: huggingface_model
      - name: label_name
        type: str
        doc: The target label of the column in the dataset.
        default: labels
      - name: text_col
        type: str
        doc: The input text column un the dataset.
        default: text
      - name: num_of_train_samples
        type: int
        doc: Max number of training samples, for debugging.
        default: null
      - name: train_test_split_size
        type: float
        doc: Should be between 0.0 and 1.0 and represent the proportion of the dataset
          to include in the test split.
        default: null
      - name: metrics
        type: List[str]
        doc: List of different metrics for evaluate the model such as f1, accuracy
          etc.
        default: null
      - name: random_state
        type: int
        doc: Random state for train_test_split
        default: null
      outputs:
      - default: ''
      lineno: 420
    preprocess_function:
      name: preprocess_function
      doc: ''
      parameters:
      - name: examples
        default: ''
      outputs:
      - default: ''
      lineno: 462
  description: Automatic train, evaluate and predict functions for the ML frameworks
    - Scikit-Learn, XGBoost and LightGBM.
  default_handler: train
  disable_auto_mount: false
  env: []
  priority_class_name: ''
  preemption_mode: prevent
  affinity: null
  tolerations: null
  security_context: {}
verbose: false
